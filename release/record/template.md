# Record (Запросы API) / Трансформация

В **Nuxoblivius** можно не только получать "_сырое_" `response.body`, но и преобразовывать его под свои нужды.
Этот процесс мы называем трансформацией ответа (или "шаблонизацией").

**С помощью встроенных механизмов вы можете**:

> 1. Удобно обращаться к данным внутри ответа.

> 2. Выполнять преобразования прямо при чтении.

> 3. Настраивать единый формат работы с **API**, чтобы избавить компоненты от "_ручной_" обработки.

## Как использовать `template()` в Record

Метод `.template()` позволяет настроить трансформацию ответа от **API** в удобный для вас формат.
Он принимает _функцию_, которая должна вернуть объект следующей структуры:

> - `data?: unknown` — преобразованные данные тела ответа (основной результат, с которым будут работать).

> - `pageCount?: number` — общее количество страниц (актуально для _пагинации_, если **API** возвращает такую информацию).

> - `protocol?: Record<string, unknown>` — дополнительные данные, которые нужно сохранить вместе с ответом (например, вычиляемые данные или метаданные).

Таким образом, `.template()` помогает вынести всю логику обработки ответа из компонентов и хранить её в одном месте.

::: info Безопасный режим
`.template()` отработает только если запрос был без ошибок, т.е. если\
`response.ok === true`
:::

```ts {5-11}
import { Record } from "nuxoblivius";

const posts = Record.new<Posts>("/api/posts", []);

posts.template((rawData: Raw<Posts>) => {
  return {
    data: rawData.items, // Сами данные
    pageCount: rawData?.meta?.pageCount ?? 1, // Сохраняем кол-во страниц
    protocol: rawData?.meta ?? {}, // Сохраняем метаданные
  };
});

posts.response.items[0].title; // [!code --]
posts.response[0].title; // [!code ++]
```

## Что такое протокол (`protocol`)?

`protocol` — это специальное место для _хранения дополнительных данных_, которые сохраняются после _трансформации ответа_.

Особенности:

> - поддерживает _типизацию_, что упрощает работу в **больших проектах**;

> - позволяет задавать _значения по умолчанию_, что делает _код более безопасным и защищает от случайных ошибок_;

> - используется для хранения служебных данных, не относящихся напрямую к data (например, _флаги_, _технические параметры_, _метаданные_).

Для создания участника протокола можно использовать метод `.defineProtocol()`.

::: code-group

```ts [Регистрация] {5-6,8-9}
import { Record } from "nuxoblivius";

const post = Record.new<Post>("/api/posts/{id}", {});

// Указываем что такой протокол существует
post.defineProtocol<string>("cutDescription", "");

// Получаем данное значение
post.protocol.cutDescription;
```

```ts [Использование] {4-7}
post.template((rawData: Raw<Post>) => {
  return {
    data: rawData, // Сам пост
    protocol: {
      // Создаём краткое описание
      cutDescription: rawData.description.slice(0, 100),
    },
  };
});
```

:::

## Создание глобального шаблона

Иногда один и тот же формат _трансформации данных_ требуется использовать в _разных запросах_. Чтобы не дублировать логику, в **Nuxoblivius** можно создавать _глобальные шаблоны_.

Для этого используется метод `RegisterTemplate()`. Он работает аналогично методу `.template()`, но принимает:

> 1. `строку` — уникальное имя шаблона;

> 2. `функцию` — саму логику трансформации.

После регистрации такой шаблон можно подключать в любом **Record** по _имени_.

::: code-group

```ts [Регистрация]
import { RegisterTemplate } from "nuxoblivius";

RegisterTemplate("my-template", (rawData: Raw<any>) => {
  return {
    data: rawData.items ?? rawData,
    pageCount: rawData?.meta?.pageCount ?? 1,
    protocol: rawData?.meta ?? {},
  };
});
```

```ts [Использование] {5}
import { Record } from "nuxoblivius";

const posts = Record.new("/api/posts", []);

posts.template("my-template");
```

:::

## Обработка данных по шаблону в любом месте

Шаблон можно вызывать не только внутри **Record**, но и в любом другом месте приложения. Это удобно, когда требуется повторно использовать одну и ту же логику преобразования.

**Метод принимает два аргумента**:

> 1. Имя шаблона (или функцию трансформации);

> 2. Данные, которые необходимо обработать.

Таким образом, вы не привязаны к **Record** и можете применять шаблон там, где это действительно нужно.

::: code-group

```ts [Функция]
import { CallPattern } from "nuxoblivius";

const { data } = CallPattern((rawData) => {
  return {
    data: rawData.items,
  };
}, myRawData);
```

```ts [По именни]
import { CallPattern } from "nuxoblivius";

const { data } = CallPattern("my-template", myRawData);
```

:::

<!-- ## Объеденение двух результатов -->
<!---->
<!-- Можно объединять (или наследовать) несколько функций обработки по шаблону. -->
<!-- Это позволяет комбинировать разные преобразования и делать код более читаемым и выразительным. -->
<!---->
<!-- Например, один шаблон может отвечать за нормализацию данных, а другой — за добавление метаинформации. Объединив их, вы получите итоговый результат в одном месте без дублирования логики. -->
<!---->
<!-- ```ts -->
<!-- import {  } -->
<!---->
<!---->
<!-- ``` -->
